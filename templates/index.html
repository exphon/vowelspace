<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vowel Space Visualizer</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ™ï¸</text></svg>">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ™ï¸ Vowel Space Visualizer</h1>
            <p class="subtitle">ëª¨ìŒ ê³µê°„ ë° í¬ë¨¼íŠ¸ ê¶¤ì  ì‹œê°í™” ë„êµ¬</p>
        </header>

        <main>
            <section class="upload-section">
                <h2>íŒŒì¼ ì—…ë¡œë“œ</h2>
                <form id="uploadForm" enctype="multipart/form-data">
                    <div class="form-group">
                        <label for="vizType">ì‹œê°í™” ìœ í˜•:</label>
                        <select id="vizType" name="viz_type">
                            <option value="static">ì •ì  ëª¨ìŒ ê³µê°„ (Static Vowel Space)</option>
                            <option value="ellipse">íƒ€ì› ëª¨ìŒ ê³µê°„ (Vowel Space with Ellipses)</option>
                            <option value="dynamic">ë™ì  í¬ë¨¼íŠ¸ ê¶¤ì  (Dynamic Formant Trajectory)</option>
                        </select>
                    </div>

                    <div class="form-group" id="ellipseOptions" style="display: none;">
                        <label>
                            <input type="checkbox" id="showPoints" name="show_points" checked>
                            ê°œë³„ ë°ì´í„° í¬ì¸íŠ¸ í‘œì‹œ
                        </label>
                        <p class="help-text">íƒ€ì›ê³¼ í•¨ê»˜ ì›ë³¸ ë°ì´í„° í¬ì¸íŠ¸ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤</p>
                    </div>

                    <div class="form-group">
                        <label for="fileInput">íŒŒì¼ ì„ íƒ:</label>
                        <input type="file" id="fileInput" name="files" multiple accept=".csv,.txt,.xlsx,.xls,.wav,.TextGrid">
                        <div class="file-info">
                            <p><strong>ì§€ì› í˜•ì‹:</strong></p>
                            <ul>
                                <li><strong>CSV/TXT/XLSX:</strong> F1, F2, vowel ì—´ í¬í•¨ (time, duration ì„ íƒì‚¬í•­)</li>
                                <li><strong>WAV + TextGrid:</strong> ìŒì„± íŒŒì¼ê³¼ ë ˆì´ë¸” íŒŒì¼ (ì„ íƒì‚¬í•­)</li>
                                <li><strong>WAV only:</strong> ìŒì„± íŒŒì¼ë§Œ (ìë™ í¬ë¨¼íŠ¸ ì¶”ì¶œ)</li>
                            </ul>
                            <p class="auto-detect-note">ğŸ’¡ <strong>ìë™ ì»¬ëŸ¼ ê°ì§€:</strong> ë‹¤ì–‘í•œ ì»¬ëŸ¼ëª…ì„ ìë™ìœ¼ë¡œ ì¸ì‹í•©ë‹ˆë‹¤ 
                            (ì˜ˆ: f1, F1, first_formant, formant_1 ë“±)</p>
                        </div>
                    </div>

                    <button type="submit" class="btn-primary">
                        <span id="uploadText">ì‹œê°í™”í•˜ê¸°</span>
                        <span id="uploadSpinner" class="spinner" style="display: none;"></span>
                    </button>
                </form>

                <div class="example-section">
                    <button id="exampleBtn" class="btn-secondary">ì˜ˆì œ ë°ì´í„° ë³´ê¸°</button>
                </div>
            </section>

            <section class="result-section" id="resultSection" style="display: none;">
                <h2>ê²°ê³¼</h2>
                
                <div class="data-info" id="dataInfo">
                    <!-- Data summary will be inserted here -->
                </div>

                <div id="plotContainer" class="plot-container">
                    <!-- Plot will be inserted here -->
                </div>

                <div class="action-buttons">
                    <button id="downloadBtn" class="btn-secondary">ê·¸ë˜í”„ ë‹¤ìš´ë¡œë“œ (PNG)</button>
                    <button id="analyzeBtn" class="btn-primary" style="display: none;">ğŸ“Š í†µê³„ ë¶„ì„ ìˆ˜í–‰</button>
                    <button id="resetBtn" class="btn-secondary">ìƒˆë¡œ ì‹œì‘</button>
                </div>
            </section>

            <section class="analysis-section" id="analysisSection" style="display: none;">
                <h2>ğŸ“Š í†µê³„ ë¶„ì„ ê²°ê³¼</h2>
                
                <div class="tabs">
                    <button class="tab-button active" data-tab="descriptive">ê¸°ìˆ í†µê³„</button>
                    <button class="tab-button" data-tab="manova">MANOVA</button>
                    <button class="tab-button" data-tab="pca">PCA</button>
                    <button class="tab-button" data-tab="lda">LDA</button>
                    <button class="tab-button" data-tab="pairwise">ìŒë³„ ê²€ì •</button>
                    <button class="tab-button" data-tab="metrics">ëª¨ìŒ ê³µê°„ ë©”íŠ¸ë¦­</button>
                </div>

                <div id="descriptive" class="tab-content active">
                    <!-- Descriptive statistics will be inserted here -->
                </div>

                <div id="manova" class="tab-content">
                    <!-- MANOVA results will be inserted here -->
                </div>

                <div id="pca" class="tab-content">
                    <!-- PCA results and plot will be inserted here -->
                </div>

                <div id="lda" class="tab-content">
                    <!-- LDA results and plot will be inserted here -->
                </div>

                <div id="pairwise" class="tab-content">
                    <!-- Pairwise test results will be inserted here -->
                </div>

                <div id="metrics" class="tab-content">
                    <!-- Vowel space metrics will be inserted here -->
                </div>
            </section>

            <section class="error-section" id="errorSection" style="display: none;">
                <div class="error-message" id="errorMessage"></div>
            </section>
        </main>

        <footer>
            <div class="info-section">
                <h3>ì‚¬ìš© ë°©ë²•</h3>
                <ol>
                    <li>ì‹œê°í™” ìœ í˜•ì„ ì„ íƒí•©ë‹ˆë‹¤ (ì •ì /ë™ì )</li>
                    <li>ë°ì´í„° íŒŒì¼ì„ ì—…ë¡œë“œí•©ë‹ˆë‹¤</li>
                    <li>ê²°ê³¼ ê·¸ë˜í”„ë¥¼ í™•ì¸í•˜ê³  ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤</li>
                </ol>
                
                <h3>ë°ì´í„° í˜•ì‹</h3>
                <div class="format-examples">
                    <div class="format-box">
                        <h4>CSV/TXT ì˜ˆì‹œ (ìë™ ê°ì§€ ê°€ëŠ¥)</h4>
                        <pre>vowel,F1,F2,time
i,300,2300,0.5
e,450,2100,1.0
a,700,1200,1.5</pre>
                        <p class="note">ë‹¤ì–‘í•œ ì»¬ëŸ¼ëª… ì‚¬ìš© ê°€ëŠ¥: f1/F1/first_formant, phone/vowel/phoneme ë“±</p>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        const uploadForm = document.getElementById('uploadForm');
        const fileInput = document.getElementById('fileInput');
        const vizTypeSelect = document.getElementById('vizType');
        const ellipseOptions = document.getElementById('ellipseOptions');
        const resultSection = document.getElementById('resultSection');
        const errorSection = document.getElementById('errorSection');
        const errorMessage = document.getElementById('errorMessage');
        const dataInfo = document.getElementById('dataInfo');
        const plotContainer = document.getElementById('plotContainer');
        const exampleBtn = document.getElementById('exampleBtn');
        const uploadText = document.getElementById('uploadText');
        const uploadSpinner = document.getElementById('uploadSpinner');
        const downloadBtn = document.getElementById('downloadBtn');
        const resetBtn = document.getElementById('resetBtn');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const analysisSection = document.getElementById('analysisSection');

        let currentPlot = null;
        let currentFiles = null;

        // Tab switching functionality
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', function() {
                const tabName = this.getAttribute('data-tab');
                
                // Remove active class from all tabs and contents
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding content
                this.classList.add('active');
                document.getElementById(tabName).classList.add('active');
            });
        });

        // Show/hide ellipse options based on visualization type
        vizTypeSelect.addEventListener('change', function() {
            if (this.value === 'ellipse') {
                ellipseOptions.style.display = 'block';
            } else {
                ellipseOptions.style.display = 'none';
            }
        });

        uploadForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const files = fileInput.files;
            if (files.length === 0) {
                showError('íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            const formData = new FormData();
            for (let file of files) {
                formData.append('files', file);
            }
            formData.append('viz_type', document.getElementById('vizType').value);
            
            // Add ellipse options if ellipse type is selected
            if (document.getElementById('vizType').value === 'ellipse') {
                formData.append('show_ellipses', 'true');
                formData.append('show_points', document.getElementById('showPoints').checked ? 'true' : 'false');
            }

            // Store files for later analysis
            currentFiles = files;

            showLoading(true);
            hideError();
            hideResult();
            hideAnalysis();

            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showResult(data);
                    
                    // Show analyze button if data has required columns
                    if (data.data_summary && data.data_summary.column_detection) {
                        analyzeBtn.style.display = 'inline-block';
                    }
                } else {
                    showError(data.error || 'íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                showError('ì„œë²„ì™€ í†µì‹  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            } finally {
                showLoading(false);
            }
        });

        exampleBtn.addEventListener('click', async () => {
            showLoading(true);
            hideError();
            hideResult();

            try {
                const response = await fetch('/example');
                const data = await response.json();

                if (response.ok && data.success) {
                    showResult(data);
                } else {
                    showError('ì˜ˆì œ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                showError('ì„œë²„ì™€ í†µì‹  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            } finally {
                showLoading(false);
            }
        });

        downloadBtn.addEventListener('click', () => {
            if (currentPlot) {
                Plotly.downloadImage(plotContainer, {
                    format: 'png',
                    width: 1200,
                    height: 900,
                    filename: 'vowel_space_plot'
                });
            }
        });

        resetBtn.addEventListener('click', () => {
            hideResult();
            hideError();
            hideAnalysis();
            uploadForm.reset();
            fileInput.value = '';
            currentFiles = null;
            analyzeBtn.style.display = 'none';
        });

        analyzeBtn.addEventListener('click', async () => {
            if (!currentFiles || currentFiles.length === 0) {
                showError('ë¶„ì„í•  íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const formData = new FormData();
            for (let file of currentFiles) {
                formData.append('files', file);
            }

            showLoading(true);
            hideError();

            try {
                const response = await fetch('/analyze', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showAnalysis(data);
                } else {
                    showError(data.error || 'í†µê³„ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                showError('ì„œë²„ì™€ í†µì‹  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            } finally {
                showLoading(false);
            }
        });

        function showResult(data) {
            // Display data summary
            if (data.data_summary) {
                const summary = data.data_summary;
                let summaryHTML = '<h3>ë°ì´í„° ìš”ì•½</h3><ul>';
                summaryHTML += `<li><strong>ì´ ë°ì´í„° í¬ì¸íŠ¸:</strong> ${summary.rows}</li>`;
                
                // ì»¬ëŸ¼ ê°ì§€ ì •ë³´ í‘œì‹œ
                if (summary.column_detection && summary.column_detection.details) {
                    summaryHTML += '<li><strong>ìë™ ê°ì§€ëœ ì»¬ëŸ¼:</strong><ul>';
                    const details = summary.column_detection.details;
                    for (const [standardName, info] of Object.entries(details)) {
                        summaryHTML += `<li><strong>${standardName}</strong>: "${info.actual_name}"`;
                        
                        if (info.min !== undefined) {
                            summaryHTML += ` (ë²”ìœ„: ${Math.round(info.min)}-${Math.round(info.max)} Hz, í‰ê· : ${Math.round(info.mean)} Hz)`;
                        } else if (info.unique_count !== undefined) {
                            summaryHTML += ` (ê³ ìœ ê°’ ${info.unique_count}ê°œ)`;
                            if (info.sample_values && info.sample_values.length > 0) {
                                summaryHTML += ` [ì˜ˆ: ${info.sample_values.join(', ')}]`;
                            }
                        }
                        summaryHTML += '</li>';
                    }
                    summaryHTML += '</ul></li>';
                }
                
                if (summary.vowels && summary.vowels.length > 0) {
                    summaryHTML += `<li><strong>ëª¨ìŒ ì¢…ë¥˜:</strong> ${summary.vowels.join(', ')}</li>`;
                }
                summaryHTML += `<li><strong>ëª¨ë“  ì»¬ëŸ¼:</strong> ${summary.columns.join(', ')}</li>`;
                summaryHTML += '</ul>';
                dataInfo.innerHTML = summaryHTML;
            }

            // Display plot
            currentPlot = data.plot;
            Plotly.newPlot(plotContainer, currentPlot.data, currentPlot.layout, {responsive: true});

            resultSection.style.display = 'block';
            resultSection.scrollIntoView({ behavior: 'smooth' });
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorSection.style.display = 'block';
            errorSection.scrollIntoView({ behavior: 'smooth' });
        }

        function hideError() {
            errorSection.style.display = 'none';
        }

        function hideResult() {
            resultSection.style.display = 'none';
        }

        function hideAnalysis() {
            analysisSection.style.display = 'none';
        }

        function showAnalysis(data) {
            const analysis = data.analysis;
            const plots = data.plots;

            // Descriptive statistics
            if (analysis.descriptive) {
                let html = '<h3>ê¸°ìˆ í†µê³„ëŸ‰</h3>';
                
                // Show statistics for each grouping variable
                for (const [groupVar, stats] of Object.entries(analysis.descriptive)) {
                    html += `<h4>${groupVar} ê¸°ì¤€</h4>`;
                    
                    if (stats.by_group && Object.keys(stats.by_group).length > 0) {
                        for (const [group, groupStats] of Object.entries(stats.by_group)) {
                            html += `<h5>${group}</h5>`;
                            html += '<table class="stats-table"><thead><tr>';
                            html += '<th>í†µê³„ëŸ‰</th><th>F1</th><th>F2</th></tr></thead><tbody>';
                            
                            if (groupStats.F1 && groupStats.F2) {
                                html += `<tr><td>í‰ê· </td><td>${groupStats.F1.mean.toFixed(2)}</td><td>${groupStats.F2.mean.toFixed(2)}</td></tr>`;
                                html += `<tr><td>í‘œì¤€í¸ì°¨</td><td>${groupStats.F1.std.toFixed(2)}</td><td>${groupStats.F2.std.toFixed(2)}</td></tr>`;
                                html += `<tr><td>ìµœì†Œê°’</td><td>${groupStats.F1.min.toFixed(2)}</td><td>${groupStats.F2.min.toFixed(2)}</td></tr>`;
                                html += `<tr><td>ìµœëŒ€ê°’</td><td>${groupStats.F1.max.toFixed(2)}</td><td>${groupStats.F2.max.toFixed(2)}</td></tr>`;
                            }
                            
                            html += '</tbody></table>';
                        }
                    }
                }
                
                document.getElementById('descriptive').innerHTML = html;
            }

            // MANOVA results - handle multiple grouping variables
            if (analysis.manova && Object.keys(analysis.manova).length > 0) {
                let html = '<h3>ë‹¤ë³€ëŸ‰ ë¶„ì‚°ë¶„ì„ (MANOVA)</h3>';
                html += '<p>ê·¸ë£¹ ê°„ F1, F2ì˜ í†µí•©ì  ì°¨ì´ë¥¼ ê²€ì •í•©ë‹ˆë‹¤.</p>';
                
                for (const [groupVar, manovaResult] of Object.entries(analysis.manova)) {
                    if (manovaResult && !manovaResult.error) {
                        html += `<h4>${groupVar} ê¸°ì¤€</h4>`;
                        
                        // Show formant-wise ANOVA results
                        if (manovaResult.formants) {
                            html += '<table class="stats-table"><thead><tr>';
                            html += '<th>Formant</th><th>F-í†µê³„ëŸ‰</th><th>p-value</th><th>ìœ ì˜ì„±</th></tr></thead><tbody>';
                            
                            for (const [formant, result] of Object.entries(manovaResult.formants)) {
                                const significant = result.significant ? 'âœ“ ìœ ì˜í•¨' : 'ìœ ì˜í•˜ì§€ ì•ŠìŒ';
                                html += `<tr><td>${formant}</td><td>${result.f_statistic.toFixed(4)}</td>`;
                                html += `<td>${result.p_value.toFixed(4)}</td><td>${significant} ${result.significance_level}</td></tr>`;
                            }
                            
                            html += '</tbody></table>';
                        }
                        
                        // Show multivariate test if available
                        if (manovaResult.multivariate) {
                            html += '<p class="note"><strong>ë‹¤ë³€ëŸ‰ ê²€ì •:</strong> ';
                            if (manovaResult.multivariate.test) {
                                html += `${manovaResult.multivariate.test} = ${manovaResult.multivariate.statistic.toFixed(4)}`;
                            }
                            if (manovaResult.multivariate.interpretation) {
                                html += ` (${manovaResult.multivariate.interpretation})`;
                            }
                            html += '</p>';
                        }
                    }
                }
                
                document.getElementById('manova').innerHTML = html;
            }

            // PCA results
            if (analysis.pca && plots.pca) {
                const pca = analysis.pca;
                let html = '<h3>ì£¼ì„±ë¶„ ë¶„ì„ (PCA)</h3>';
                html += '<p>F1ê³¼ F2ì˜ ë³€ë™ì„ ì£¼ì„±ë¶„ìœ¼ë¡œ ìš”ì•½í•©ë‹ˆë‹¤.</p>';
                
                html += '<table class="stats-table"><thead><tr>';
                html += '<th>ì£¼ì„±ë¶„</th><th>ì„¤ëª…ëœ ë¶„ì‚° (%)</th></tr></thead><tbody>';
                
                pca.explained_variance_ratio.forEach((ratio, idx) => {
                    html += `<tr><td>PC${idx + 1}</td><td>${(ratio * 100).toFixed(2)}%</td></tr>`;
                });
                
                html += '</tbody></table>';
                
                html += '<div id="pcaPlot" class="plot-container"></div>';
                
                document.getElementById('pca').innerHTML = html;
                
                // Render PCA plot
                setTimeout(() => {
                    Plotly.newPlot('pcaPlot', plots.pca.data, plots.pca.layout, {responsive: true});
                }, 100);
            }

            // LDA results - handle multiple LDA analyses
            if (analysis.lda && Object.keys(analysis.lda).length > 0) {
                let html = '<h3>ì„ í˜• íŒë³„ ë¶„ì„ (LDA)</h3>';
                html += '<p>ê·¸ë£¹ì„ ìµœëŒ€í•œ ë¶„ë¦¬í•˜ëŠ” íŒë³„í•¨ìˆ˜ë¥¼ ì°¾ìŠµë‹ˆë‹¤.</p>';
                
                // Show LDA for each grouping variable
                for (const [groupVar, ldaResult] of Object.entries(analysis.lda)) {
                    if (ldaResult && !ldaResult.error) {
                        const plotKey = `lda_${groupVar}`;
                        const plotId = `ldaPlot_${groupVar}`;
                        
                        html += `<h4>${groupVar} ê¸°ì¤€ LDA</h4>`;
                        html += '<table class="stats-table"><thead><tr>';
                        html += '<th>ë©”íŠ¸ë¦­</th><th>ê°’</th></tr></thead><tbody>';
                        
                        html += `<tr><td>íŒë³„í•¨ìˆ˜ ê°œìˆ˜</td><td>${ldaResult.n_components}</td></tr>`;
                        html += `<tr><td>ë¶„ë¥˜ ì •í™•ë„</td><td>${(ldaResult.accuracy * 100).toFixed(2)}%</td></tr>`;
                        html += `<tr><td>ê·¸ë£¹ ìˆ˜</td><td>${ldaResult.n_groups}</td></tr>`;
                        
                        html += '</tbody></table>';
                        
                        if (plots[plotKey]) {
                            html += `<div id="${plotId}" class="plot-container"></div>`;
                        }
                    }
                }
                
                document.getElementById('lda').innerHTML = html;
                
                // Render all LDA plots
                setTimeout(() => {
                    for (const [groupVar, ldaResult] of Object.entries(analysis.lda)) {
                        if (ldaResult && !ldaResult.error) {
                            const plotKey = `lda_${groupVar}`;
                            const plotId = `ldaPlot_${groupVar}`;
                            
                            if (plots[plotKey]) {
                                Plotly.newPlot(plotId, plots[plotKey].data, plots[plotKey].layout, {responsive: true});
                            }
                        }
                    }
                }, 100);
            }

            // Pairwise tests - handle multiple grouping variables
            if (analysis.pairwise && Object.keys(analysis.pairwise).length > 0) {
                let html = '<h3>ìŒë³„ t-ê²€ì •</h3>';
                html += '<p>ëª¨ë“  ê·¸ë£¹ ìŒì— ëŒ€í•´ F1, F2ì˜ ì°¨ì´ë¥¼ ê²€ì •í•©ë‹ˆë‹¤.</p>';
                
                for (const [groupVar, pairwiseResult] of Object.entries(analysis.pairwise)) {
                    if (pairwiseResult && !pairwiseResult.error && pairwiseResult.comparisons) {
                        html += `<h4>${groupVar} ê¸°ì¤€</h4>`;
                        
                        // Group comparisons by formant
                        const byFormant = { F1: {}, F2: {} };
                        
                        for (const [pair, formantResults] of Object.entries(pairwiseResult.comparisons)) {
                            for (const [formant, result] of Object.entries(formantResults)) {
                                byFormant[formant][pair] = result;
                            }
                        }
                        
                        // Display tables for each formant
                        for (const [formant, comparisons] of Object.entries(byFormant)) {
                            if (Object.keys(comparisons).length > 0) {
                                html += `<h5>${formant}</h5>`;
                                html += '<table class="stats-table"><thead><tr>';
                                html += '<th>ë¹„êµ</th><th>t-í†µê³„ëŸ‰</th><th>p-value</th><th>Cohen\'s d</th><th>íš¨ê³¼í¬ê¸°</th></tr></thead><tbody>';
                                
                                for (const [pair, result] of Object.entries(comparisons)) {
                                    const effectSize = Math.abs(result.cohens_d) < 0.2 ? 'ì‘ìŒ' : 
                                                      Math.abs(result.cohens_d) < 0.5 ? 'ì¤‘ê°„' : 
                                                      Math.abs(result.cohens_d) < 0.8 ? 'í¼' : 'ë§¤ìš° í¼';
                                    const significant = result.significant ? ' class="significant"' : '';
                                    
                                    html += `<tr${significant}><td>${pair}</td>`;
                                    html += `<td>${result.t_statistic.toFixed(3)}</td>`;
                                    html += `<td>${result.p_value.toFixed(4)}</td>`;
                                    html += `<td>${result.cohens_d.toFixed(3)}</td>`;
                                    html += `<td>${effectSize}</td></tr>`;
                                }
                                
                                html += '</tbody></table>';
                            }
                        }
                    }
                }
                
                html += '<p class="note">* p < 0.05ì¸ ê²½ìš° ê°•ì¡° í‘œì‹œ</p>';
                
                document.getElementById('pairwise').innerHTML = html;
            }

            // Vowel space metrics - handle multiple grouping variables
            if (analysis.vowel_space && Object.keys(analysis.vowel_space).length > 0) {
                let html = '<h3>ëª¨ìŒ ê³µê°„ ë©”íŠ¸ë¦­</h3>';
                html += '<p>ëª¨ìŒ ê³µê°„ì˜ í¬ê¸°ì™€ ë¶„ì‚°ë„ë¥¼ ì •ëŸ‰í™”í•©ë‹ˆë‹¤.</p>';
                
                for (const [groupVar, metricsResult] of Object.entries(analysis.vowel_space)) {
                    if (metricsResult) {
                        html += `<h4>${groupVar} ê¸°ì¤€</h4>`;
                        
                        // Overall metrics
                        if (metricsResult.overall && !metricsResult.overall.error) {
                            const metrics = metricsResult.overall;
                            html += '<h5>ì „ì²´</h5>';
                            html += '<table class="stats-table"><thead><tr>';
                            html += '<th>ë©”íŠ¸ë¦­</th><th>ê°’</th><th>ì„¤ëª…</th></tr></thead><tbody>';
                            
                            if (metrics.area !== undefined) {
                                html += `<tr><td>ëª¨ìŒ ê³µê°„ ë©´ì </td><td>${metrics.area.toFixed(2)}</td>`;
                                html += '<td>ëª¨ìŒë“¤ì´ í˜•ì„±í•˜ëŠ” ë‹¤ê°í˜•ì˜ ë©´ì  (HzÂ²)</td></tr>';
                            }
                            
                            if (metrics.centroid_F1 !== undefined && metrics.centroid_F2 !== undefined) {
                                html += `<tr><td>ì¤‘ì‹¬ì </td><td>F1: ${metrics.centroid_F1.toFixed(2)}, F2: ${metrics.centroid_F2.toFixed(2)}</td>`;
                                html += '<td>ëª¨ë“  ëª¨ìŒì˜ í‰ê·  ìœ„ì¹˜</td></tr>';
                            }
                            
                            if (metrics.dispersion !== undefined) {
                                html += `<tr><td>ë¶„ì‚°ë„</td><td>${metrics.dispersion.toFixed(2)}</td>`;
                                html += '<td>ì¤‘ì‹¬ì ìœ¼ë¡œë¶€í„°ì˜ í‰ê·  ê±°ë¦¬</td></tr>';
                            }
                            
                            html += '</tbody></table>';
                        }
                        
                        // Group-wise metrics
                        if (metricsResult.by_group && Object.keys(metricsResult.by_group).length > 0) {
                            for (const [group, metrics] of Object.entries(metricsResult.by_group)) {
                                if (metrics && !metrics.error) {
                                    html += `<h5>${group}</h5>`;
                                    html += '<table class="stats-table"><thead><tr>';
                                    html += '<th>ë©”íŠ¸ë¦­</th><th>ê°’</th></tr></thead><tbody>';
                                    
                                    if (metrics.area !== undefined) {
                                        html += `<tr><td>ë©´ì </td><td>${metrics.area.toFixed(2)} HzÂ²</td></tr>`;
                                    }
                                    
                                    if (metrics.dispersion !== undefined) {
                                        html += `<tr><td>ë¶„ì‚°ë„</td><td>${metrics.dispersion.toFixed(2)}</td></tr>`;
                                    }
                                    
                                    html += '</tbody></table>';
                                }
                            }
                        }
                    }
                }
                
                document.getElementById('metrics').innerHTML = html;
            }

            analysisSection.style.display = 'block';
            analysisSection.scrollIntoView({ behavior: 'smooth' });
        }

        function showLoading(isLoading) {
            if (isLoading) {
                uploadText.style.display = 'none';
                uploadSpinner.style.display = 'inline-block';
                uploadForm.querySelector('button[type="submit"]').disabled = true;
            } else {
                uploadText.style.display = 'inline';
                uploadSpinner.style.display = 'none';
                uploadForm.querySelector('button[type="submit"]').disabled = false;
            }
        }
    </script>
</body>
</html>
