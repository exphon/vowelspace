<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vowel Space Visualizer</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéôÔ∏è</text></svg>">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>üéôÔ∏è Vowel Space Visualizer</h1>
            <p class="subtitle">Vowel Space and Formant Trajectory Visualization Tool</p>
        </header>

        <main>
            <section class="upload-section">
                <h2>File Upload</h2>
                <form id="uploadForm" enctype="multipart/form-data">
                    <div class="form-group">
                        <label for="vizType">Visualization Type:</label>
                        <select id="vizType" name="viz_type">
                            <option value="static">Static Vowel Space</option>
                            <option value="ellipse">Vowel Space with Ellipses</option>
                            <option value="dynamic">Dynamic Formant Trajectory</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="formantScale">Formant Scale:</label>
                        <select id="formantScale" name="formant_scale">
                            <option value="Hz" selected>Hz (Hertz)</option>
                            <option value="Bark">Bark</option>
                            <option value="ERB">ERB (Equivalent Rectangular Bandwidth)</option>
                            <option value="Mel">Mel</option>
                        </select>
                        <p class="help-text">Select the frequency scale for formant display. Uploaded data is assumed to be in Hz and will be automatically converted.</p>
                    </div>

                    <div class="form-group" id="ellipseOptions" style="display: none;">
                        <label>
                            <input type="checkbox" id="showPoints" name="show_points" checked>
                            Show Individual Data Points
                        </label>
                        <p class="help-text">Display original data points along with ellipses</p>
                    </div>

                    <div class="form-group">
                        <label for="fileInput">Select File:</label>
                        <div class="custom-file-upload">
                            <input type="file" id="fileInput" name="files" multiple accept=".csv,.txt,.xlsx,.xls,.wav,.TextGrid">
                            <label for="fileInput" class="file-upload-label">
                                <span class="file-upload-button">Choose Files</span>
                                <span class="file-upload-text" id="fileUploadText">No file selected</span>
                            </label>
                        </div>
                        <div class="file-info">
                            <p><strong>Supported Formats:</strong></p>
                            <ul>
                                <li><strong>CSV/TXT/XLSX:</strong> Must include F1, F2, vowel columns (time, duration optional)</li>
                                <li><strong>WAV + TextGrid:</strong> Audio file with label file - Extracts formants from labeled vowel segments</li>
                                <li><strong>WAV only:</strong> Audio file only (automatic formant extraction)</li>
                            </ul>
                            <p class="auto-detect-note">üí° <strong>Auto Column Detection:</strong> Automatically recognizes various column names 
                            (e.g., f1, F1, first_formant, formant_1, etc.)</p>
                            
                            <details class="extraction-method">
                                <summary><strong>üìñ TextGrid Formant Extraction Method</strong></summary>
                                <div class="method-details">
                                    <p><strong>How formants are extracted from WAV + TextGrid files:</strong></p>
                                    <ol>
                                        <li><strong>Audio Processing:</strong> WAV files are automatically resampled to 16kHz for optimal formant analysis</li>
                                        <li><strong>Vowel Detection:</strong> Only vowel segments (ARPABET: AH, IY, etc. / IPA: …™,  ä, …ô, etc.) are analyzed</li>
                                        <li><strong>Sampling Region:</strong> Formants are measured from the <strong>middle 25% of each vowel's duration</strong> (37.5% ~ 62.5% timepoints) to avoid coarticulation effects</li>
                                        <li><strong>Averaging:</strong> 5 measurement points within the middle region are sampled and averaged for stability</li>
                                        <li><strong>Quality Control:</strong> Outliers beyond ¬±3 standard deviations (per vowel type) are automatically removed</li>
                                        <li><strong>Praat Settings:</strong> Formant extraction uses Burg's method with 5 formants, 5500Hz ceiling, 25ms window, 10ms time step</li>
                                    </ol>
                                    <p class="note-box">üìä <strong>Result:</strong> Each vowel segment yields one F1/F2 measurement pair (averaged and rounded to 1 decimal place)</p>
                                </div>
                            </details>
                        </div>
                    </div>

                    <button type="submit" class="btn-primary">
                        <span id="uploadText">Visualize</span>
                        <span id="uploadSpinner" class="spinner" style="display: none;"></span>
                    </button>
                </form>

                <div class="example-section">
                    <button id="exampleBtn" class="btn-secondary">View Example Data</button>
                    <button id="downloadExampleBtn" class="btn-secondary">üì• Download Example Data</button>
                </div>
            </section>

            <section class="result-section" id="resultSection" style="display: none;">
                <h2>Results</h2>
                
                <div class="data-info" id="dataInfo">
                    <!-- Data summary will be inserted here -->
                </div>

                <div id="plotContainer" class="plot-container">
                    <!-- Plot will be inserted here -->
                </div>

                <div class="action-buttons">
                    <button id="downloadBtn" class="btn-secondary">Download Chart (PNG)</button>
                    <button id="downloadCsvBtn" class="btn-secondary" style="display: none;">üì• Download Extracted Data (CSV)</button>
                    <button id="analyzeBtn" class="btn-primary" style="display: none;">üìä Perform Statistical Analysis</button>
                    <button id="resetBtn" class="btn-secondary">Start Over</button>
                </div>
            </section>

            <section class="analysis-section" id="analysisSection" style="display: none;">
                <h2>üìä Statistical Analysis Results</h2>
                
                <div class="tabs">
                    <button class="tab-button active" data-tab="descriptive">Descriptive Statistics</button>
                    <button class="tab-button" data-tab="manova">MANOVA</button>
                    <button class="tab-button" data-tab="pca">PCA</button>
                    <button class="tab-button" data-tab="lda">LDA</button>
                    <button class="tab-button" data-tab="statistical-plots">Statistical Plots</button>
                    <button class="tab-button" data-tab="pairwise">Pairwise Tests</button>
                    <button class="tab-button" data-tab="metrics">Vowel Space Metrics</button>
                </div>

                <div id="descriptive" class="tab-content active">
                    <!-- Descriptive statistics will be inserted here -->
                </div>

                <div id="manova" class="tab-content">
                    <!-- MANOVA results will be inserted here -->
                </div>

                <div id="pca" class="tab-content">
                    <!-- PCA results and plot will be inserted here -->
                </div>

                <div id="lda" class="tab-content">
                    <!-- LDA results and plot will be inserted here -->
                </div>

                <div id="statistical-plots" class="tab-content">
                    <!-- Statistical plots will be inserted here -->
                </div>

                <div id="pairwise" class="tab-content">
                    <!-- Pairwise test results will be inserted here -->
                </div>

                <div id="metrics" class="tab-content">
                    <!-- Vowel space metrics will be inserted here -->
                </div>
            </section>

            <section class="error-section" id="errorSection" style="display: none;">
                <div class="error-message" id="errorMessage"></div>
            </section>
        </main>

        <footer>
            <div class="info-section">
                <h3>How to Use</h3>
                <ol>
                    <li>Select visualization type (static/dynamic)</li>
                    <li>Upload data file</li>
                    <li>View and download the result chart</li>
                </ol>
                
                <h3>Data Format</h3>
                <div class="format-examples">
                    <div class="format-box">
                        <h4>CSV/TXT Example (Auto-detection supported)</h4>
                        <pre>vowel,F1,F2,time
i,300,2300,0.5
e,450,2100,1.0
a,700,1200,1.5</pre>
                        <p class="note">Various column names supported: f1/F1/first_formant, phone/vowel/phoneme, etc.</p>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        const uploadForm = document.getElementById('uploadForm');
        const fileInput = document.getElementById('fileInput');
        const vizTypeSelect = document.getElementById('vizType');
        const ellipseOptions = document.getElementById('ellipseOptions');
        const resultSection = document.getElementById('resultSection');
        const errorSection = document.getElementById('errorSection');
        const errorMessage = document.getElementById('errorMessage');
        const dataInfo = document.getElementById('dataInfo');
        const plotContainer = document.getElementById('plotContainer');
        const exampleBtn = document.getElementById('exampleBtn');
        const uploadText = document.getElementById('uploadText');
        const uploadSpinner = document.getElementById('uploadSpinner');
        const downloadBtn = document.getElementById('downloadBtn');
        const resetBtn = document.getElementById('resetBtn');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const analysisSection = document.getElementById('analysisSection');

        let currentPlot = null;
        let currentFiles = null;

        // File input change handler to update text
        fileInput.addEventListener('change', function() {
            const fileUploadText = document.getElementById('fileUploadText');
            if (this.files.length > 0) {
                if (this.files.length === 1) {
                    fileUploadText.textContent = this.files[0].name;
                } else {
                    fileUploadText.textContent = `${this.files.length} files selected`;
                }
            } else {
                fileUploadText.textContent = 'No file selected';
            }
        });

        // Tab switching functionality
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', function() {
                const tabName = this.getAttribute('data-tab');
                
                // Remove active class from all tabs and contents
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding content
                this.classList.add('active');
                document.getElementById(tabName).classList.add('active');
            });
        });

        // Show/hide ellipse options based on visualization type
        vizTypeSelect.addEventListener('change', function() {
            if (this.value === 'ellipse') {
                ellipseOptions.style.display = 'block';
            } else {
                ellipseOptions.style.display = 'none';
            }
        });

        uploadForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const files = fileInput.files;
            if (files.length === 0) {
                showError('Please select a file.');
                return;
            }

            const formData = new FormData();
            for (let file of files) {
                formData.append('files', file);
            }
            formData.append('viz_type', document.getElementById('vizType').value);
            formData.append('formant_scale', document.getElementById('formantScale').value);
            
            // Add ellipse options if ellipse type is selected
            if (document.getElementById('vizType').value === 'ellipse') {
                formData.append('show_ellipses', 'true');
                formData.append('show_points', document.getElementById('showPoints').checked ? 'true' : 'false');
            }

            // Store files for later analysis
            currentFiles = files;

            showLoading(true);
            hideError();
            hideResult();
            hideAnalysis();

            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showResult(data);
                    
                    // Show analyze button if data has required columns
                    if (data.data_summary && data.data_summary.column_detection) {
                        analyzeBtn.style.display = 'inline-block';
                    }
                } else {
                    showError(data.error || 'An error occurred while processing the file.');
                }
            } catch (error) {
                showError('An error occurred while communicating with the server: ' + error.message);
            } finally {
                showLoading(false);
            }
        });

        exampleBtn.addEventListener('click', async () => {
            showLoading(true);
            hideError();
            hideResult();

            try {
                const response = await fetch('/example');
                const data = await response.json();

                if (response.ok && data.success) {
                    showResult(data);
                } else {
                    showError('An error occurred while loading the example data.');
                }
            } catch (error) {
                showError('An error occurred while communicating with the server: ' + error.message);
            } finally {
                showLoading(false);
            }
        });

        // Download example data button
        const downloadExampleBtn = document.getElementById('downloadExampleBtn');
        downloadExampleBtn.addEventListener('click', () => {
            // Create a temporary link and trigger download
            const link = document.createElement('a');
            link.href = '/download-examples';
            link.download = 'vowelspace_examples.zip';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        downloadBtn.addEventListener('click', () => {
            if (currentPlot) {
                Plotly.downloadImage(plotContainer, {
                    format: 'png',
                    width: 1200,
                    height: 900,
                    filename: 'vowel_space_plot'
                });
            }
        });

        // Download extracted CSV data button
        const downloadCsvBtn = document.getElementById('downloadCsvBtn');
        downloadCsvBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.href = '/download-extracted-data';
            link.download = 'extracted_vowel_formants.csv';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        resetBtn.addEventListener('click', () => {
            hideResult();
            hideError();
            hideAnalysis();
            uploadForm.reset();
            fileInput.value = '';
            currentFiles = null;
            analyzeBtn.style.display = 'none';
            downloadCsvBtn.style.display = 'none';
        });

        analyzeBtn.addEventListener('click', async () => {
            if (!currentFiles || currentFiles.length === 0) {
                showError('There is no file to analyze.');
                return;
            }

            const formData = new FormData();
            for (let file of currentFiles) {
                formData.append('files', file);
            }
            
            // Add formant scale
            formData.append('formant_scale', document.getElementById('formantScale').value);

            showLoading(true);
            hideError();

            try {
                const response = await fetch('/analyze', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showAnalysis(data);
                } else {
                    showError(data.error || 'An error occurred during statistical analysis.');
                }
            } catch (error) {
                showError('An error occurred while communicating with the server: ' + error.message);
            } finally {
                showLoading(false);
            }
        });

        function showResult(data) {
            // Check if this is WAV/TextGrid data (has extracted data available)
            const isWavData = data.data_source === 'wav_textgrid';
            const downloadCsvBtn = document.getElementById('downloadCsvBtn');
            
            if (isWavData) {
                downloadCsvBtn.style.display = 'inline-block';
            } else {
                downloadCsvBtn.style.display = 'none';
            }
            
            // Display data summary
            if (data.data_summary) {
                const summary = data.data_summary;
                let summaryHTML = '<h3>Data Summary</h3><ul>';
                summaryHTML += `<li><strong>Total Data Points:</strong> ${summary.rows}</li>`;
                
                // Display column detection information
                if (summary.column_detection && summary.column_detection.details) {
                    summaryHTML += '<li><strong>Auto-detected Columns:</strong><ul>';
                    const details = summary.column_detection.details;
                    for (const [standardName, info] of Object.entries(details)) {
                        summaryHTML += `<li><strong>${standardName}</strong>: "${info.actual_name}"`;
                        
                        if (info.min !== undefined) {
                            // Determine unit based on column type
                            let unit = 'Hz';
                            if (standardName === 'duration') {
                                unit = 'ms';
                            } else if (standardName === 'time') {
                                unit = 's';
                            }
                            
                            summaryHTML += ` (Range: ${Math.round(info.min)}-${Math.round(info.max)} ${unit}, Mean: ${Math.round(info.mean)} ${unit})`;
                        } else if (info.unique_count !== undefined) {
                            summaryHTML += ` (${info.unique_count} unique values)`;
                            if (info.sample_values && info.sample_values.length > 0) {
                                summaryHTML += ` [e.g.: ${info.sample_values.join(', ')}]`;
                            }
                        }
                        summaryHTML += '</li>';
                    }
                    summaryHTML += '</ul></li>';
                }
                
                if (summary.vowels && summary.vowels.length > 0) {
                    summaryHTML += `<li><strong>Vowel Types:</strong> ${summary.vowels.join(', ')}</li>`;
                }
                summaryHTML += `<li><strong>All Columns:</strong> ${summary.columns.join(', ')}</li>`;
                summaryHTML += '</ul>';
                dataInfo.innerHTML = summaryHTML;
            }

            // Display plot
            currentPlot = data.plot;
            Plotly.newPlot(plotContainer, currentPlot.data, currentPlot.layout, {responsive: true});

            resultSection.style.display = 'block';
            resultSection.scrollIntoView({ behavior: 'smooth' });
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorSection.style.display = 'block';
            errorSection.scrollIntoView({ behavior: 'smooth' });
        }

        function hideError() {
            errorSection.style.display = 'none';
        }

        function hideResult() {
            resultSection.style.display = 'none';
        }

        function hideAnalysis() {
            analysisSection.style.display = 'none';
        }

        function showAnalysis(data) {
            const analysis = data.analysis;
            const plots = data.plots;

            // Descriptive statistics
            if (analysis.descriptive) {
                let html = '<h3>Descriptive Statistics</h3>';
                
                // Show statistics for each grouping variable
                for (const [groupVar, stats] of Object.entries(analysis.descriptive)) {
                    html += `<h4>By ${groupVar}</h4>`;
                    
                    if (stats.by_group && Object.keys(stats.by_group).length > 0) {
                        for (const [group, groupStats] of Object.entries(stats.by_group)) {
                            html += `<h5>${group}</h5>`;
                            html += '<table class="stats-table"><thead><tr>';
                            html += '<th>Statistic</th><th>F1</th><th>F2</th></tr></thead><tbody>';
                            
                            if (groupStats.F1 && groupStats.F2) {
                                html += `<tr><td>Mean</td><td>${groupStats.F1.mean.toFixed(2)}</td><td>${groupStats.F2.mean.toFixed(2)}</td></tr>`;
                                html += `<tr><td>Std Dev</td><td>${groupStats.F1.std.toFixed(2)}</td><td>${groupStats.F2.std.toFixed(2)}</td></tr>`;
                                html += `<tr><td>Min</td><td>${groupStats.F1.min.toFixed(2)}</td><td>${groupStats.F2.min.toFixed(2)}</td></tr>`;
                                html += `<tr><td>Max</td><td>${groupStats.F1.max.toFixed(2)}</td><td>${groupStats.F2.max.toFixed(2)}</td></tr>`;
                            }
                            
                            html += '</tbody></table>';
                        }
                    }
                }
                
                document.getElementById('descriptive').innerHTML = html;
            }

            // MANOVA results - handle multiple grouping variables
            if (analysis.manova && Object.keys(analysis.manova).length > 0) {
                let html = '<h3>Multivariate Analysis of Variance (MANOVA)</h3>';
                html += '<p>Tests for integrated differences in F1 and F2 between groups.</p>';
                
                for (const [groupVar, manovaResult] of Object.entries(analysis.manova)) {
                    if (manovaResult && !manovaResult.error) {
                        html += `<h4>By ${groupVar}</h4>`;
                        
                        // Show formant-wise ANOVA results
                        if (manovaResult.formants) {
                            html += '<table class="stats-table"><thead><tr>';
                            html += '<th>Formant</th><th>F-statistic</th><th>p-value</th><th>Significance</th></tr></thead><tbody>';
                            
                            for (const [formant, result] of Object.entries(manovaResult.formants)) {
                                const significant = result.significant ? '‚úì Significant' : 'Not significant';
                                html += `<tr><td>${formant}</td><td>${result.f_statistic.toFixed(4)}</td>`;
                                html += `<td>${result.p_value.toFixed(4)}</td><td>${significant} ${result.significance_level}</td></tr>`;
                            }
                            
                            html += '</tbody></table>';
                        }
                        
                        // Show multivariate test if available
                        if (manovaResult.multivariate) {
                            html += '<p class="note"><strong>Multivariate Test:</strong> ';
                            if (manovaResult.multivariate.test) {
                                html += `${manovaResult.multivariate.test} = ${manovaResult.multivariate.statistic.toFixed(4)}`;
                            }
                            if (manovaResult.multivariate.interpretation) {
                                html += ` (${manovaResult.multivariate.interpretation})`;
                            }
                            html += '</p>';
                        }
                    }
                }
                
                document.getElementById('manova').innerHTML = html;
            }

            // PCA results
            if (analysis.pca && plots.pca) {
                const pca = analysis.pca;
                let html = '<h3>Principal Component Analysis (PCA)</h3>';
                html += '<p>Summarizes variation in F1 and F2 into principal components.</p>';
                
                html += '<table class="stats-table"><thead><tr>';
                html += '<th>Principal Component</th><th>Explained Variance (%)</th></tr></thead><tbody>';
                
                pca.explained_variance_ratio.forEach((ratio, idx) => {
                    html += `<tr><td>PC${idx + 1}</td><td>${(ratio * 100).toFixed(2)}%</td></tr>`;
                });
                
                html += '</tbody></table>';
                
                html += '<div id="pcaPlot" class="plot-container"></div>';
                
                document.getElementById('pca').innerHTML = html;
                
                // Render PCA plot
                setTimeout(() => {
                    Plotly.newPlot('pcaPlot', plots.pca.data, plots.pca.layout, {responsive: true});
                }, 100);
            }

            // LDA results - handle multiple LDA analyses
            if (analysis.lda && Object.keys(analysis.lda).length > 0) {
                let html = '<h3>Linear Discriminant Analysis (LDA)</h3>';
                html += '<p>Finds discriminant functions that maximally separate groups.</p>';
                
                // Show LDA for each grouping variable
                for (const [groupVar, ldaResult] of Object.entries(analysis.lda)) {
                    if (ldaResult && !ldaResult.error) {
                        const plotKey = `lda_${groupVar}`;
                        const plotId = `ldaPlot_${groupVar}`;
                        
                        html += `<h4>LDA by ${groupVar}</h4>`;
                        html += '<table class="stats-table"><thead><tr>';
                        html += '<th>Metric</th><th>Value</th></tr></thead><tbody>';
                        
                        html += `<tr><td>Number of Discriminants</td><td>${ldaResult.n_components}</td></tr>`;
                        html += `<tr><td>Classification Accuracy</td><td>${(ldaResult.accuracy * 100).toFixed(2)}%</td></tr>`;
                        html += `<tr><td>Number of Groups</td><td>${ldaResult.n_groups}</td></tr>`;
                        
                        html += '</tbody></table>';
                        
                        if (plots[plotKey]) {
                            html += `<div id="${plotId}" class="plot-container"></div>`;
                        }
                    }
                }
                
                document.getElementById('lda').innerHTML = html;
                
                // Render all LDA plots
                setTimeout(() => {
                    for (const [groupVar, ldaResult] of Object.entries(analysis.lda)) {
                        if (ldaResult && !ldaResult.error) {
                            const plotKey = `lda_${groupVar}`;
                            const plotId = `ldaPlot_${groupVar}`;
                            
                            if (plots[plotKey]) {
                                Plotly.newPlot(plotId, plots[plotKey].data, plots[plotKey].layout, {responsive: true});
                            }
                        }
                    }
                }, 100);
            }

            // Statistical Plots
            if (plots && Object.keys(plots).length > 0) {
                let html = '<h3>Statistical Plots</h3>';
                html += '<p>Visualize data distributions through various statistical graphs.</p>';
                
                // Box plots
                const boxplots = Object.keys(plots).filter(k => k.startsWith('boxplot_'));
                if (boxplots.length > 0) {
                    html += '<h4>üì¶ Box Plot</h4>';
                    html += '<p>Visualizes the distribution and outliers of formant values. The box represents the 25-75 percentile range, and the line indicates the median.</p>';
                    boxplots.forEach(plotKey => {
                        const groupVar = plotKey.replace('boxplot_', '');
                        const plotId = `plot_${plotKey}`;
                        html += `<h5>By ${groupVar}</h5>`;
                        html += `<div id="${plotId}" class="plot-container"></div>`;
                    });
                }
                
                // Violin plots
                const violinPlots = Object.keys(plots).filter(k => k.startsWith('violin_'));
                if (violinPlots.length > 0) {
                    html += '<h4>üéª Violin Plot</h4>';
                    html += '<p>Adds probability density to box plots to show the shape of data distribution in more detail.</p>';
                    violinPlots.forEach(plotKey => {
                        const groupVar = plotKey.replace('violin_', '');
                        const plotId = `plot_${plotKey}`;
                        html += `<h5>By ${groupVar}</h5>`;
                        html += `<div id="${plotId}" class="plot-container"></div>`;
                    });
                }
                
                // Density Plots (Histograms)
                const histograms = Object.keys(plots).filter(k => k.startsWith('histogram_'));
                if (histograms.length > 0) {
                    html += '<h4>üìä Density Plot</h4>';
                    html += '<p>Shows the <strong>probability density distribution</strong> of F1 and F2 values as smooth curves. ';
                    html += 'Provides a more continuous and smooth distribution shape than histograms, representing the probability of each formant value. ';
                    html += 'The height of the curve indicates the density (probability) of that value, with peaks representing the most frequent values.</p>';
                    histograms.forEach(plotKey => {
                        const groupVar = plotKey.replace('histogram_', '');
                        const plotId = `plot_${plotKey}`;
                        html += `<h5>By ${groupVar}</h5>`;
                        html += `<div id="${plotId}" class="plot-container"></div>`;
                    });
                }
                
                // Mean comparison plots
                const meanPlots = Object.keys(plots).filter(k => k.startsWith('mean_comparison_'));
                if (meanPlots.length > 0) {
                    html += '<h4>üìà Mean Comparison</h4>';
                    html += '<p>Compares mean formant values and standard errors for each group.</p>';
                    meanPlots.forEach(plotKey => {
                        const groupVar = plotKey.replace('mean_comparison_', '');
                        const plotId = `plot_${plotKey}`;
                        html += `<h5>By ${groupVar}</h5>`;
                        html += `<div id="${plotId}" class="plot-container"></div>`;
                    });
                }
                
                // Pairwise comparison plots
                const pairwisePlots = Object.keys(plots).filter(k => k.startsWith('pairwise_'));
                if (pairwisePlots.length > 0) {
                    html += '<h4>üî¨ Pairwise Comparisons</h4>';
                    html += '<p>Shows statistical significance of differences between each pair of groups.</p>';
                    html += '<p style="font-size: 0.9em; color: #666;">*** p < 0.001, ** p < 0.01, * p < 0.05, ns = not significant</p>';
                    pairwisePlots.forEach(plotKey => {
                        const groupVar = plotKey.replace('pairwise_', '');
                        const plotId = `plot_${plotKey}`;
                        html += `<h5>By ${groupVar}</h5>`;
                        html += `<div id="${plotId}" class="plot-container"></div>`;
                    });
                }
                
                // Scatter matrix
                if (plots.scatter_matrix) {
                    html += '<h4>üî≤ Scatter Matrix</h4>';
                    html += '<div class="info-box" style="background: #e7f3ff; padding: 1.5rem; border-radius: 8px; margin-bottom: 1rem;">';
                    html += '<h5 style="margin-top: 0; color: #0066cc;">üìä What is a Scatter Matrix?</h5>';
                    html += '<p style="line-height: 1.6;">A scatter matrix is a visualization tool that shows <strong>pairwise relationships</strong> between multiple variables at a glance.</p>';
                    
                    html += '<h5 style="color: #0066cc; margin-top: 1rem;">üîç Diagonal (F1 vs F1, F2 vs F2)</h5>';
                    html += '<ul style="line-height: 1.8;">';
                    html += '<li><strong>F1 vs F1:</strong> Shows the <strong>distribution (histogram)</strong> of F1 values. You can see how F1 values are distributed for each vowel.</li>';
                    html += '<li><strong>F2 vs F2:</strong> Shows the <strong>distribution (histogram)</strong> of F2 values. You can see how F2 values are distributed for each vowel.</li>';
                    html += '<li><strong>Meaning:</strong> Understand distribution patterns of a single variable - whether it is normally distributed, has multiple peaks, etc.</li>';
                    html += '</ul>';
                    
                    html += '<h5 style="color: #0066cc; margin-top: 1rem;">üìà Off-diagonal (F1 vs F2)</h5>';
                    html += '<ul style="line-height: 1.8;">';
                    html += '<li><strong>F1 vs F2 scatter plot:</strong> Shows the <strong>correlation</strong> between the two formants.</li>';
                    html += '<li><strong>Relationship with vowels:</strong> See how each vowel is separated in the F1-F2 space</li>';
                    html += '<li><strong>Cluster patterns:</strong> Identify whether same vowels cluster together or overlap with other vowels</li>';
                    html += '</ul>';
                    
                    html += '<h5 style="color: #0066cc; margin-top: 1rem;">üéØ Application in Vowel Analysis</h5>';
                    html += '<ul style="line-height: 1.8;">';
                    html += '<li><strong>Vowel separation:</strong> Are vowels clearly distinguished in the F1-F2 space?</li>';
                    html += '<li><strong>Variability comparison:</strong> Is the variability in F1 or F2 greater?</li>';
                    html += '<li><strong>Correlation patterns:</strong> Does F2 increase when F1 increases for certain vowels? (positive correlation)</li>';
                    html += '<li><strong>Outlier detection:</strong> Discover values that are far from other data points</li>';
                    html += '</ul>';
                    
                    html += '<p style="margin-top: 1rem; padding: 1rem; background: #fff3cd; border-radius: 6px; border-left: 4px solid #ffc107;">';
                    html += 'üí° <strong>Interpretation Tip:</strong> Color represents vowels. If the same color (same vowel) clusters in one area, the vowel is stably pronounced, ';
                    html += 'and if scattered in multiple places, there is high pronunciation variation. If vowel clusters are well separated in the F1 vs F2 scatter plot, ';
                    html += 'they are acoustically distinct.';
                    html += '</p>';
                    html += '</div>';
                    
                    html += '<div id="plot_scatter_matrix" class="plot-container"></div>';
                }
                
                document.getElementById('statistical-plots').innerHTML = html;
                
                // Render all statistical plots
                setTimeout(() => {
                    // Render boxplots
                    boxplots.forEach(plotKey => {
                        const plotId = `plot_${plotKey}`;
                        if (plots[plotKey]) {
                            Plotly.newPlot(plotId, plots[plotKey].data, plots[plotKey].layout, {responsive: true});
                        }
                    });
                    
                    // Render violin plots
                    violinPlots.forEach(plotKey => {
                        const plotId = `plot_${plotKey}`;
                        if (plots[plotKey]) {
                            Plotly.newPlot(plotId, plots[plotKey].data, plots[plotKey].layout, {responsive: true});
                        }
                    });
                    
                    // Render histograms
                    histograms.forEach(plotKey => {
                        const plotId = `plot_${plotKey}`;
                        if (plots[plotKey]) {
                            Plotly.newPlot(plotId, plots[plotKey].data, plots[plotKey].layout, {responsive: true});
                        }
                    });
                    
                    // Render mean comparison plots
                    meanPlots.forEach(plotKey => {
                        const plotId = `plot_${plotKey}`;
                        if (plots[plotKey]) {
                            Plotly.newPlot(plotId, plots[plotKey].data, plots[plotKey].layout, {responsive: true});
                        }
                    });
                    
                    // Render pairwise comparison plots
                    pairwisePlots.forEach(plotKey => {
                        const plotId = `plot_${plotKey}`;
                        if (plots[plotKey]) {
                            Plotly.newPlot(plotId, plots[plotKey].data, plots[plotKey].layout, {responsive: true});
                        }
                    });
                    
                    // Render scatter matrix
                    if (plots.scatter_matrix) {
                        Plotly.newPlot('plot_scatter_matrix', plots.scatter_matrix.data, plots.scatter_matrix.layout, {responsive: true});
                    }
                }, 100);
            }

            // Pairwise tests - handle multiple grouping variables
            if (analysis.pairwise && Object.keys(analysis.pairwise).length > 0) {
                let html = '<h3>Pairwise t-tests</h3>';
                html += '<p>Tests differences in F1 and F2 for all group pairs.</p>';
                
                for (const [groupVar, pairwiseResult] of Object.entries(analysis.pairwise)) {
                    if (pairwiseResult && !pairwiseResult.error && pairwiseResult.comparisons) {
                        html += `<h4>By ${groupVar}</h4>`;
                        
                        // Group comparisons by formant
                        const byFormant = { F1: {}, F2: {} };
                        
                        for (const [pair, formantResults] of Object.entries(pairwiseResult.comparisons)) {
                            for (const [formant, result] of Object.entries(formantResults)) {
                                byFormant[formant][pair] = result;
                            }
                        }
                        
                        // Display tables for each formant
                        for (const [formant, comparisons] of Object.entries(byFormant)) {
                            if (Object.keys(comparisons).length > 0) {
                                html += `<h5>${formant}</h5>`;
                                html += '<table class="stats-table"><thead><tr>';
                                html += '<th>Comparison</th><th>t-statistic</th><th>p-value</th><th>Cohen\'s d</th><th>Effect Size</th></tr></thead><tbody>';
                                
                                for (const [pair, result] of Object.entries(comparisons)) {
                                    const effectSize = Math.abs(result.cohens_d) < 0.2 ? 'Small' : 
                                                      Math.abs(result.cohens_d) < 0.5 ? 'Medium' : 
                                                      Math.abs(result.cohens_d) < 0.8 ? 'Large' : 'Very Large';
                                    const significant = result.significant ? ' class="significant"' : '';
                                    
                                    html += `<tr${significant}><td>${pair}</td>`;
                                    html += `<td>${result.t_statistic.toFixed(3)}</td>`;
                                    html += `<td>${result.p_value.toFixed(4)}</td>`;
                                    html += `<td>${result.cohens_d.toFixed(3)}</td>`;
                                    html += `<td>${effectSize}</td></tr>`;
                                }
                                
                                html += '</tbody></table>';
                            }
                        }
                    }
                }
                
                html += '<p class="note">* Highlighted when p < 0.05</p>';
                
                document.getElementById('pairwise').innerHTML = html;
            }

            // Vowel space metrics - handle multiple grouping variables
            if (analysis.vowel_space && Object.keys(analysis.vowel_space).length > 0) {
                let html = '<h3>Vowel Space Metrics</h3>';
                html += '<p>Quantifies the size and dispersion of the vowel space.</p>';
                
                for (const [groupVar, metricsResult] of Object.entries(analysis.vowel_space)) {
                    if (metricsResult) {
                        html += `<h4>By ${groupVar}</h4>`;
                        
                        // Overall metrics
                        if (metricsResult.overall && !metricsResult.overall.error) {
                            const metrics = metricsResult.overall;
                            html += '<h5>Overall</h5>';
                            html += '<table class="stats-table"><thead><tr>';
                            html += '<th>Metric</th><th>Value</th><th>Description</th></tr></thead><tbody>';
                            
                            if (metrics.area !== undefined) {
                                html += `<tr><td>Vowel Space Area</td><td>${metrics.area.toFixed(2)}</td>`;
                                html += '<td>Area of the polygon formed by vowels (Hz¬≤)</td></tr>';
                            }
                            
                            if (metrics.centroid_F1 !== undefined && metrics.centroid_F2 !== undefined) {
                                html += `<tr><td>Centroid</td><td>F1: ${metrics.centroid_F1.toFixed(2)}, F2: ${metrics.centroid_F2.toFixed(2)}</td>`;
                                html += '<td>Average position of all vowels</td></tr>';
                            }
                            
                            if (metrics.dispersion !== undefined) {
                                html += `<tr><td>Dispersion</td><td>${metrics.dispersion.toFixed(2)}</td>`;
                                html += '<td>Average distance from centroid</td></tr>';
                            }
                            
                            html += '</tbody></table>';
                        }
                        
                        // Group-wise metrics
                        if (metricsResult.by_group && Object.keys(metricsResult.by_group).length > 0) {
                            for (const [group, metrics] of Object.entries(metricsResult.by_group)) {
                                if (metrics && !metrics.error) {
                                    html += `<h5>${group}</h5>`;
                                    html += '<table class="stats-table"><thead><tr>';
                                    html += '<th>Metric</th><th>Value</th></tr></thead><tbody>';
                                    
                                    if (metrics.area !== undefined) {
                                        html += `<tr><td>Area</td><td>${metrics.area.toFixed(2)} Hz¬≤</td></tr>`;
                                    }
                                    
                                    if (metrics.dispersion !== undefined) {
                                        html += `<tr><td>Dispersion</td><td>${metrics.dispersion.toFixed(2)}</td></tr>`;
                                    }
                                    
                                    html += '</tbody></table>';
                                }
                            }
                        }
                    }
                }
                
                document.getElementById('metrics').innerHTML = html;
            }

            analysisSection.style.display = 'block';
            analysisSection.scrollIntoView({ behavior: 'smooth' });
        }

        function showLoading(isLoading) {
            if (isLoading) {
                uploadText.style.display = 'none';
                uploadSpinner.style.display = 'inline-block';
                uploadForm.querySelector('button[type="submit"]').disabled = true;
            } else {
                uploadText.style.display = 'inline';
                uploadSpinner.style.display = 'none';
                uploadForm.querySelector('button[type="submit"]').disabled = false;
            }
        }
    </script>
</body>
</html>
